"""
Basic Malware Scanner Module
Implements basic malware detection patterns for APK files.
"""

import logging
import re
import hashlib
from pathlib import Path
from typing import Dict, List, Set, Optional, Tuple, Any
import xml.etree.ElementTree as ET

from .utils import get_data_dir


class MalwareScanner:
    """Basic malware detection for APK files."""

    def __init__(self):
        self.logger = logging.getLogger(__name__)
        self.data_dir = get_data_dir()
        self.malware_patterns = self._load_malware_patterns()
        self.suspicious_permissions = self._load_suspicious_permissions()
        self.suspicious_apis = self._load_suspicious_apis()

    def scan_apk(self, decompiled_dir: Path) -> Dict[str, Any]:
        """
        Perform basic malware scan on decompiled APK.

        Args:
            decompiled_dir: Path to decompiled APK directory

        Returns:
            Dictionary with scan results
        """
        results = {
            "risk_level": "LOW",  # LOW, MEDIUM, HIGH, CRITICAL
            "threats_found": [],
            "suspicious_permissions": [],
            "suspicious_apis": [],
            "obfuscation_detected": False,
            "network_analysis": {},
            "file_analysis": {},
            "recommendations": [],
        }

        self.logger.info("Starting malware scan")

        try:
            # Analyze manifest for suspicious permissions
            manifest_results = self._analyze_manifest_security(decompiled_dir)
            results.update(manifest_results)

            # Analyze smali code for suspicious patterns
            code_results = self._analyze_code_patterns(decompiled_dir)
            results.update(code_results)

            # Analyze network-related code
            network_results = self._analyze_network_behavior(decompiled_dir)
            results["network_analysis"] = network_results

            # Check for obfuscation
            obfuscation_results = self._detect_obfuscation(decompiled_dir)
            results["obfuscation_detected"] = obfuscation_results

            # Calculate overall risk level
            results["risk_level"] = self._calculate_risk_level(results)

            # Generate recommendations
            results["recommendations"] = self._generate_recommendations(results)

        except Exception as e:
            self.logger.error(f"Error during malware scan: {e}")
            results["scan_error"] = str(e)

        return results

    def _load_malware_patterns(self) -> List[Dict[str, str]]:
        """Load malware signature patterns."""
        patterns = []

        try:
            patterns_file = self.data_dir / "malware_patterns.txt"
            if patterns_file.exists():
                with open(patterns_file, "r", encoding="utf-8") as f:
                    for line in f:
                        line = line.strip()
                        if line and not line.startswith("#"):
                            # Format: pattern_type:pattern:description
                            parts = line.split(":", 2)
                            if len(parts) == 3:
                                patterns.append({"type": parts[0], "pattern": parts[1], "description": parts[2]})
            else:
                # Default malware patterns
                patterns.extend(
                    [
                        {"type": "string", "pattern": "sendTextMessage", "description": "SMS sending capability"},
                        {"type": "string", "pattern": "getDeviceId", "description": "Device ID access"},
                        {"type": "string", "pattern": "getSubscriberId", "description": "Subscriber ID access"},
                        {"type": "string", "pattern": "getSimSerialNumber", "description": "SIM serial access"},
                        {"type": "string", "pattern": "getNetworkOperator", "description": "Network operator access"},
                        {"type": "string", "pattern": "Runtime.exec", "description": "System command execution"},
                        {"type": "string", "pattern": "ProcessBuilder", "description": "Process creation"},
                        {"type": "string", "pattern": "DexClassLoader", "description": "Dynamic code loading"},
                        {"type": "string", "pattern": "PathClassLoader", "description": "Dynamic code loading"},
                        {
                            "type": "regex",
                            "pattern": r"http://\d+\.\d+\.\d+\.\d+",
                            "description": "Direct IP connection",
                        },
                        {"type": "string", "pattern": "su", "description": "Root access attempt"},
                        {"type": "string", "pattern": "/system/bin/", "description": "System binary access"},
                    ]
                )

        except Exception as e:
            self.logger.error(f"Error loading malware patterns: {e}")

        self.logger.info(f"Loaded {len(patterns)} malware patterns")
        return patterns

    def _load_suspicious_permissions(self) -> Set[str]:
        """Load suspicious Android permissions."""
        permissions = set()

        try:
            perms_file = self.data_dir / "suspicious_permissions.txt"
            if perms_file.exists():
                with open(perms_file, "r", encoding="utf-8") as f:
                    for line in f:
                        perm = line.strip()
                        if perm and not perm.startswith("#"):
                            permissions.add(perm)
            else:
                # Default suspicious permissions
                permissions.update(
                    [
                        "android.permission.SEND_SMS",
                        "android.permission.READ_SMS",
                        "android.permission.RECEIVE_SMS",
                        "android.permission.READ_PHONE_STATE",
                        "android.permission.CALL_PHONE",
                        "android.permission.RECORD_AUDIO",
                        "android.permission.CAMERA",
                        "android.permission.ACCESS_FINE_LOCATION",
                        "android.permission.ACCESS_COARSE_LOCATION",
                        "android.permission.READ_CONTACTS",
                        "android.permission.WRITE_CONTACTS",
                        "android.permission.GET_ACCOUNTS",
                        "android.permission.WRITE_EXTERNAL_STORAGE",
                        "android.permission.SYSTEM_ALERT_WINDOW",
                        "android.permission.DEVICE_ADMIN",
                        "android.permission.BIND_DEVICE_ADMIN",
                        "android.permission.INSTALL_PACKAGES",
                        "android.permission.DELETE_PACKAGES",
                        "android.permission.MOUNT_UNMOUNT_FILESYSTEMS",
                        "android.permission.WRITE_SECURE_SETTINGS",
                    ]
                )

        except Exception as e:
            self.logger.error(f"Error loading suspicious permissions: {e}")

        return permissions

    def _load_suspicious_apis(self) -> Set[str]:
        """Load suspicious API calls."""
        apis = set()

        # Common suspicious API patterns
        apis.update(
            [
                "TelephonyManager",
                "SmsManager",
                "AudioRecord",
                "MediaRecorder",
                "LocationManager",
                "ContactsContract",
                "AccountManager",
                "DevicePolicyManager",
                "PackageInstaller",
                "Runtime.exec",
                "ProcessBuilder",
                "DexClassLoader",
                "PathClassLoader",
                "URLClassLoader",
            ]
        )

        return apis

    def _analyze_manifest_security(self, decompiled_dir: Path) -> Dict[str, Any]:
        """Analyze AndroidManifest.xml for security issues."""
        results = {"suspicious_permissions": [], "threats_found": []}

        try:
            manifest_path = decompiled_dir / "AndroidManifest.xml"
            if not manifest_path.exists():
                return results

            tree = ET.parse(manifest_path)
            root = tree.getroot()

            # Check permissions
            for perm_elem in root.findall("uses-permission"):
                perm_name = perm_elem.get("{http://schemas.android.com/apk/res/android}name", "")
                if perm_name in self.suspicious_permissions:
                    results["suspicious_permissions"].append(perm_name)

            # Check for dangerous permission combinations
            perms = set(results["suspicious_permissions"])

            if "android.permission.SEND_SMS" in perms and "android.permission.READ_PHONE_STATE" in perms:
                results["threats_found"].append(
                    {
                        "type": "SMS_FRAUD",
                        "description": "App can send SMS and read phone state - potential SMS fraud",
                        "severity": "HIGH",
                    }
                )

            if "android.permission.RECORD_AUDIO" in perms and "android.permission.ACCESS_FINE_LOCATION" in perms:
                results["threats_found"].append(
                    {
                        "type": "SPYWARE",
                        "description": "App can record audio and access location - potential spyware",
                        "severity": "HIGH",
                    }
                )

            if "android.permission.DEVICE_ADMIN" in perms:
                results["threats_found"].append(
                    {
                        "type": "DEVICE_ADMIN",
                        "description": "App requests device admin privileges - potential ransomware",
                        "severity": "CRITICAL",
                    }
                )

            # Check for exported components without proper protection
            app_elem = root.find("application")
            if app_elem is not None:
                for component_type in ["activity", "service", "receiver"]:
                    for component in app_elem.findall(component_type):
                        exported = component.get("{http://schemas.android.com/apk/res/android}exported", "false")
                        if exported.lower() == "true":
                            # Check if it has proper intent filters or permissions
                            intent_filters = component.findall("intent-filter")
                            if not intent_filters:
                                results["threats_found"].append(
                                    {
                                        "type": "EXPOSED_COMPONENT",
                                        "description": f"Exported {component_type} without intent filter",
                                        "severity": "MEDIUM",
                                    }
                                )

        except Exception as e:
            self.logger.error(f"Error analyzing manifest security: {e}")

        return results

    def _analyze_code_patterns(self, decompiled_dir: Path) -> Dict[str, Any]:
        """Analyze smali code for malicious patterns."""
        results = {"threats_found": [], "suspicious_apis": []}

        try:
            smali_dir = decompiled_dir / "smali"
            if not smali_dir.exists():
                return results

            # Find all smali files
            smali_files = list(smali_dir.rglob("*.smali"))

            for smali_file in smali_files:
                try:
                    with open(smali_file, "r", encoding="utf-8") as f:
                        content = f.read()

                    # Check for malware patterns
                    for pattern_info in self.malware_patterns:
                        pattern = pattern_info["pattern"]
                        pattern_type = pattern_info["type"]
                        description = pattern_info["description"]

                        if pattern_type == "string" and pattern in content:
                            results["threats_found"].append(
                                {
                                    "type": "SUSPICIOUS_CODE",
                                    "description": f"Found suspicious pattern: {description}",
                                    "file": str(smali_file.relative_to(decompiled_dir)),
                                    "pattern": pattern,
                                    "severity": "MEDIUM",
                                }
                            )
                        elif pattern_type == "regex":
                            matches = re.findall(pattern, content)
                            if matches:
                                results["threats_found"].append(
                                    {
                                        "type": "SUSPICIOUS_CODE",
                                        "description": f"Found suspicious pattern: {description}",
                                        "file": str(smali_file.relative_to(decompiled_dir)),
                                        "matches": matches,
                                        "severity": "MEDIUM",
                                    }
                                )

                    # Check for suspicious API usage
                    for api in self.suspicious_apis:
                        if api in content:
                            results["suspicious_apis"].append(
                                {"api": api, "file": str(smali_file.relative_to(decompiled_dir))}
                            )

                except Exception as e:
                    self.logger.error(f"Error analyzing {smali_file}: {e}")

        except Exception as e:
            self.logger.error(f"Error analyzing code patterns: {e}")

        return results

    def _analyze_network_behavior(self, decompiled_dir: Path) -> Dict[str, Any]:
        """Analyze network-related behavior."""
        results = {"urls_found": [], "ip_addresses": [], "suspicious_domains": []}

        try:
            smali_dir = decompiled_dir / "smali"
            if not smali_dir.exists():
                return results

            # Patterns for network analysis
            url_pattern = re.compile(r'https?://[^\s"\'<>]+')
            ip_pattern = re.compile(r"\b(?:\d{1,3}\.){3}\d{1,3}\b")

            smali_files = list(smali_dir.rglob("*.smali"))

            for smali_file in smali_files:
                try:
                    with open(smali_file, "r", encoding="utf-8") as f:
                        content = f.read()

                    # Find URLs
                    urls = url_pattern.findall(content)
                    results["urls_found"].extend(urls)

                    # Find IP addresses
                    ips = ip_pattern.findall(content)
                    results["ip_addresses"].extend(ips)

                except Exception as e:
                    self.logger.error(f"Error analyzing network behavior in {smali_file}: {e}")

            # Remove duplicates
            results["urls_found"] = list(set(results["urls_found"]))
            results["ip_addresses"] = list(set(results["ip_addresses"]))

            # Check for suspicious domains
            suspicious_tlds = [".tk", ".ml", ".ga", ".cf", ".onion"]
            for url in results["urls_found"]:
                for tld in suspicious_tlds:
                    if tld in url:
                        results["suspicious_domains"].append(url)
                        break

        except Exception as e:
            self.logger.error(f"Error analyzing network behavior: {e}")

        return results

    def _detect_obfuscation(self, decompiled_dir: Path) -> bool:
        """Detect code obfuscation."""
        try:
            smali_dir = decompiled_dir / "smali"
            if not smali_dir.exists():
                return False

            # Check for obfuscated class names (single letters, numbers)
            obfuscated_count = 0
            total_classes = 0

            for smali_file in smali_dir.rglob("*.smali"):
                total_classes += 1
                class_name = smali_file.stem

                # Check if class name looks obfuscated
                if (
                    len(class_name) <= 2
                    or class_name.isdigit()
                    or re.match(r"^[a-z]$", class_name)
                    or re.match(r"^[A-Z]$", class_name)
                ):
                    obfuscated_count += 1

            # If more than 30% of classes look obfuscated
            if total_classes > 0 and (obfuscated_count / total_classes) > 0.3:
                return True

        except Exception as e:
            self.logger.error(f"Error detecting obfuscation: {e}")

        return False

    def _calculate_risk_level(self, results: Dict[str, Any]) -> str:
        """Calculate overall risk level based on findings."""
        risk_score = 0

        # Count threats by severity
        for threat in results.get("threats_found", []):
            severity = threat.get("severity", "LOW")
            if severity == "CRITICAL":
                risk_score += 10
            elif severity == "HIGH":
                risk_score += 5
            elif severity == "MEDIUM":
                risk_score += 2
            else:  # LOW
                risk_score += 1

        # Add points for suspicious permissions
        risk_score += len(results.get("suspicious_permissions", [])) * 0.5

        # Add points for obfuscation
        if results.get("obfuscation_detected", False):
            risk_score += 3

        # Add points for suspicious network behavior
        network = results.get("network_analysis", {})
        risk_score += len(network.get("suspicious_domains", [])) * 2
        risk_score += len(network.get("ip_addresses", [])) * 0.5

        # Determine risk level
        if risk_score >= 15:
            return "CRITICAL"
        elif risk_score >= 8:
            return "HIGH"
        elif risk_score >= 3:
            return "MEDIUM"
        else:
            return "LOW"

    def _generate_recommendations(self, results: Dict[str, Any]) -> List[str]:
        """Generate security recommendations based on scan results."""
        recommendations = []

        risk_level = results.get("risk_level", "LOW")

        if risk_level in ["CRITICAL", "HIGH"]:
            recommendations.append("⚠️ This APK shows signs of malicious behavior. Do not install.")
            recommendations.append("Consider reporting this APK to security researchers.")

        if results.get("obfuscation_detected", False):
            recommendations.append("Code obfuscation detected - this may hide malicious functionality.")

        suspicious_perms = results.get("suspicious_permissions", [])
        if "android.permission.DEVICE_ADMIN" in suspicious_perms:
            recommendations.append("App requests device admin - be very cautious as this can be used for ransomware.")

        if "android.permission.SEND_SMS" in suspicious_perms:
            recommendations.append("App can send SMS - monitor your SMS charges after installation.")

        network = results.get("network_analysis", {})
        if network.get("suspicious_domains"):
            recommendations.append("App connects to suspicious domains - may leak personal data.")

        if not recommendations:
            recommendations.append(
                "✅ No major security concerns detected, but always be cautious with APKs from unknown sources."
            )

        return recommendations
